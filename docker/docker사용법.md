# 01/04

## docker란?

> 리눅스 운영체제에서 지원하는 다양한 기능을 사용해 컨테이너(하나의 프로세스)를 실행하기 위한 별도의 환경(파일 시스템)을 준비하고, 리눅스 네임스페이스와 다양한 커널 기능을 조합해 프로세스를 특별하게 실행시켜 준다.
>
> 이는 가상머신과 같이 하드웨어를 가상화하는 것이 아니라, 운영체제 상에서 지원하는 방법을 통해 하나의 프로세스(컨테이너)를 실행하기 위한 별도의 환경을 구축하는 일을 지원하고, 도커는 바로 프로세스를 격리시켜 실행해주는 도구이다.



## 컨테이너

> 개별 소프트웨어의 실행에 필요한 실행환경을 독립적으로 운용할 수 있도록 기반환경 또는 다른 실행환경과의 간섭을 막고 **실행의 독립성을 확보해주는 운영체계 수준의 격리 기술**
>
> 컨테이너는 애플리케이션을 실제 구동 환경으로부터 **추상화**할 수 있는 논리 패키징 매커니즘을 제공한다.

- 소프트웨어의 실행을 위해선 OS와 Library를 포함, 소프트웨어가 필요로 하는 파일 등으로 구성된 실행환경이 필요한데, 하나의 시스템 위에서 둘 이상의 소프트웨어를 동시에 실행하려고 한다면 문제가 발생할 수 있다.
- ex) software A와 B가 동일한 라이브러리를 사용하지만 서로 다른 버전을 필요로 하는 경우나 두 소프트웨어의 운영 체제가 다를 경우 등 다양한 경우에서 문제가 발생할 수 있다.
-  이런 상황에서 가장 간단한 해결책은 두 소프트웨어를 위한 시스템을 각각 준비하는 것인데 시스템을 각각 준비할 경우 비용의 문제가 발생하게 됨(10개의 소프트웨어일 경우 10개의 시스템이 필요)
- 이러한 문제를 효율적으로 해결한 것이 바로 컨테이너



## 이미지

> 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않는다.

- 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장된다.
- 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있다.

### 1. Doker Layer

- 도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백메가MB에 이른다. 처음 이미지를 다운받을 땐 크게 부담이 되지 않지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적이다
- 이러한 문제를 해결하기 위한 개념이 Layer이다.
- 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해준다
- 이미지는 여러개의 읽기 전용 read only레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성된다.
- ex) ubuntu 이미지가 `A` + `B` + `C`의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 `A` + `B` + `C` + `nginx`가 됩니다.



## 컨테이너 실행하기

도커를 실행하는 명령어는 다음과 같습니다.

```
doker run [options] IMAGE[:TAG|@DIGESET] [COMMAND] [ARG...]
```

다음은 자주 사용하는 옵션들입니다.

| 옵션  | 설명                                                   |
| :---- | :----------------------------------------------------- |
| -d    | detached mode 흔히 말하는 백그라운드 모드              |
| -p    | 호스트와 컨테이너의 포트를 연결 (포워딩)               |
| -v    | 호스트와 컨테이너의 디렉토리를 연결 (마운트)           |
| -e    | 컨테이너 내에서 사용할 환경변수 설정                   |
| -name | 컨테이너 이름 설정                                     |
| -rm   | 프로세스 종료시 컨테이너 자동 제거                     |
| -it   | -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션 |
| -link | 컨테이너 연결 [컨테이너명:별칭]                        |



## 도커 기본 명령어

##### 컨테이너 목록 확인하기 (ps)

```
docker ps [OPTIONS]
```

##### 컨테이너 중지하기 (stop)

```
docker stop [OPTIONS] CONTAINER [CONTAINER...]
```

- 도커 ID의 전체 길이는 64자리 입니다. 하지만 명령어의 인자로 전달할 때는 전부 입력하지 않아도 됩니다. 예를 들어 ID가 abcdefgh…라면 abcd만 입력해도 됩니다. 앞부분이 겹치지 않는다면 1-2자만 입력해도 됩니다.

##### 컨테이너 제거하기 (rm)

- 종료된 컨테이너를 완전히 제거

```
docker rm [OPTIONS] CONTAINER [CONTAINER...]
```

- 중지된 컨테이너 ID를 가져와서 한번에 삭제

```
docker rm -v $(docker ps -a -q -f status=exited)
```

##### 이미지 목록 확인하기 (images)

```
docker images [OPTIONS] [REPOSITORY[:TAG]]
```

##### 이미지 다운로드 하기 (pull)

```
docker pull [OPTIONS] NAME[:TAG|@DIGEST]
```

##### 이미지 삭제하기 (rmi)

```
docker rmi [OPTIONS] IMAGE [IMAGE...]
```

- images 명령어를 통해 얻은 이미지 목록에서 이미지 ID를 입력하면 삭제가 된다.
- 단, 컨테이너가 실행중인 이미지는 삭제되지 않는다.
- 컨테이너는 이미지들의 레이어를 기반으로 실행중이므로 당연히 삭제할 수 없다.

##### 컨테이너 로그 보기(logs)

- 컨테이너가 정상적으로 동작하는지 확인하는 좋은 방법은 로그를 확인하는 것이다

```
docker logs [OPTIONS] CONTAINER
```

##### 컨테이너 명령어 실행하기 (exec)

- 실행중인 컨테이너에 들어가거나 컨테이너의 파일을 실행하고 싶을 때가 있다.
- run은 새로 컨테이너를 만들어서 실행하고 exec은 실행중인 컨테이너에 명령어로 실행한다.

```
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```







